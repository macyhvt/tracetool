<?php die('Not Allowed!');
// Register required libraries.
use Box\Spout\Common\Exception\IOException;
use Box\Spout\Reader\Common\Creator\ReaderEntityFactory;
use Box\Spout\Reader\Exception\ReaderNotOpenedException;
use Joomla\Registry\Registry;
use Joomla\Utilities\ArrayHelper;
use Nematrack\App;
use Nematrack\Helper\DatabaseHelper;
use Nematrack\Helper\JsonHelper;
use Nematrack\Model;
use Nematrack\Model\Techparams;
use Symfony\Component\Finder\Exception\DirectoryNotFoundException;
use Symfony\Component\Finder\Finder;

/* no direct script access */
defined ('_FTK_APP_') OR die('403 FORBIDDEN'); ?>
<?php /* Init vars */
$lang    = $this->get('language');
$view    = $this->__get('view');
$input   = $view->get('input');
$model   = $view->get('model');
$dbo     = $model->get('db');
$user    = $view->get('user');

$partModel = $model->getInstance('part', ['language' => $lang]);

$layout  = $input->getCmd('layout');
?>
<?php /* Access check */
if (is_a($user, 'Nematrack\Entity\User')) :
	try
	{
		$formData = $user->__get('formData');
		$formData = (is_array($formData)) ? $formData : [];
	}
	catch (Exception $e)
	{
		$formData = null;
	}
endif;

//TODO - Implement ACL and make calculate editor-right from ACL
$canDo = true;
?>
<?php /* Process form data */
$task   = $input->post->getCmd('task',    $input->getCmd('task'));
$format = $input->post->getWord('format', $input->getWord('format'));

if (!is_null($task)) :
	switch ($task) :
	endswitch;
endif;
?>
<?php /* Load view data */
// Define the project to which log data files shall be imported.
$project        = 'BBB';
$project        = Model::getInstance('project')->getProjectByNumber($project);
$projectNumber  = $project->get('number');
$projectStatus  = $project->get('status');
$mpTolerance    = $project->get('config')->factors->{$projectStatus};

// Define look up directory.
$directory      = implode(DIRECTORY_SEPARATOR, [	FTKPATH_TEMP, 'pressone', $projectNumber]);
// Ensure the path is an absolute system path.
$directoryABS   = App::getRouter()->fixRoute($directory);

// Prepare regular expression to identify CSV files.
// Pattern: ^([A-Z0-9]{3}\-){2}[A-Z0-9]{3}@([\w\d]{3}\.)([\w\d]{3}\.)([\w\d]{2}\.)([\w\d]{5}\.)([\w\d]{3})(\w|\d|\-)+\.csv$
$csvFilePattern = sprintf('^%s@%s%s\.csv$',
	ltrim(rtrim(FTKREGEX_TRACKINGCODE, '$'), '^'),
	ltrim(rtrim(FTKREGEX_DRAWING_NUMBER, '$'), '^'),
	ltrim(rtrim('(\w|\d|\-)+', '$'), '^')
);

// Initialise Symfony file loader object.
$finder         = new Finder;

// Tell the file loader the lookup directory.
try
{
	$finder
	->in(App::getRouter()->fixRoute($directoryABS))->followLinks()
	->sortByName();
}
catch (DirectoryNotFoundException | LogicException $e)
{
	die($e->getMessage());
}

// Define table references.
$tableMPDefs    = 'article_process_mp_definition';
$columnsMPDefs  = (array) DatabaseHelper::getTableColumns($tableMPDefs);	// 1 ref
$tableTrk       = 'part_techparameter';
$columnsTrk     = (array) DatabaseHelper::getTableColumns($tableTrk);		// 1 ref
$tableMPData    = 'part_process_mp_tracking';
$columnsMPData  = (array) DatabaseHelper::getTableColumns($tableMPData);	// 3 refs
$tableSCFData   = 'part_process_scf_tracking';
$columnsSCFData = (array) DatabaseHelper::getTableColumns($tableSCFData);	// 4 refs

// Drop column 'timestamp'. This is auto-populated by MySQL.
// unset($columnsMPData[ array_search('timestamp', $columnsMPData)]);
unset($columnsSCFData[array_search('timestamp', $columnsSCFData)]);

// Define flags needed to identify the correct measuring point sub-field.
// This is not required for every type of measuring like for e.g. temperature,
// but it is required if min. two physical information relate to each other like
// e.g. Force/Distance or Force/Time.
$mpIdentifiersMap   = new Registry([
	'mnt' => ['F','S'], // F = force, S = distance
	'scf' => ['F','S'], // F = force, S = distance
]);

// Define abstract mock object, that maps log file properties to the database table columns.
$mockObject         = new Registry([
	'code'         => null,
	'article'      => null,
	'process'      => null,
	'machine'      => null,
	'config'       => null,
	'operator'     => null,
	'pressFit'     => null, // a part may have to pass more than 1 press-in processes
	'batch'        => null,
	'measurement'  => null, // e.g. 'Force/Distance',
	'unit'         => null, // e.g. 'N/mm',
	'analysis'     => [     // the measuring data analysis like it is done in Excel
		'DistanceMax' => null,
		'Fmax'        => null,
		'FmaxGLMW5'   => null,
		'FmaxGLMW20'  => null,
		'Similarity'  => null,
	],
	'tracking'     => [     // the measuring data analysis like it was presented in Excel by SMa
		'F' => null, // aka Fmax ... must match the related process marker as defined in $mpIdentifiersMap
		'S' => null  // aka Smax ... must match the related process marker as defined in $mpIdentifiersMap
	],
	'measuredData' => [],   // the measuring data logged by the machine while pressing
]);

// Define concrete data object, which receives all CSV data to be stored into the log data table.
$rowData            = null;

// Define helper functions.
$calculateDistances = function(array $data): array {
	// Convert negative values to positive values.
	array_walk($data, function(&$value)
	{
//		$value = $value < 0 ? ($value * -1) : $value;
		$value = abs($value);
	});

	$reference = current($data);
	$list      = [];

	array_walk($data, function($value) use(&$reference, &$list)
	{
		array_push($list, $value - $reference);
	});

	return $list;
};
$calculateForceGLMW = function(array $data, int $offset, int $decimals = 2) : array {
	$cnt  = count($data);
	$list = [];

	for ($i = 0, $j = $offset; $i < $cnt; $i += 1) :
		$slice = array_slice($data, $i, $j);

		if (count($slice) == $offset) :
			$avg   = \Nematrack\Helper\ArrayHelper::average($slice, $decimals);

			array_push($list, $avg);
		endif;
	endfor;

	return $list;
};
$calculateValidity  = function($mpValue, array $mpDefinition) : string {
//	echo '<pre>' . print_r(str_repeat('+', 80), true) . '</pre>';
//	$projectStatus = $project->get('status');
//	$mpTolerance   = $project->get('config')->factors->$projectStatus;
//	$mpToleranceFactor = $project->get('config')->factors->$projectStatus;

//	echo '<pre>projectStatus: ' . print_r($projectStatus, true) . '</pre>';
//	echo '<pre>mpTolerance: '   . print_r($mpTolerance, true) . '</pre>';
//	echo '<pre>mpValue: '       . print_r($mpValue, true) . '</pre>';
//	echo '<pre>mpDefinition: '  . print_r($mpDefinition, true) . '</pre>';
//	die('HALT');

	$mpValue           = floatval($mpValue);
	$mpNominal         = floatval($mpDefinition['mpNominal']);
	$mpLowerTolerance  = floatval($mpDefinition['mpLowerTol']);
	$mpUpperTolerance  = floatval($mpDefinition['mpUpperTol']);
	$mpToleranceFactor = floatval($mpDefinition['mpToleranceFactor']);
	$mpLowerLimit      = floatval($mpNominal - ($mpToleranceFactor * $mpLowerTolerance));
	$mpUpperLimit      = floatval($mpNominal + ($mpToleranceFactor * $mpUpperTolerance));

	echo '<pre>  Check value (' . gettype($mpValue) . '): '   . print_r($mpValue, true) . '</pre>';
	echo '<pre>  Against tolerance Spectrum: ' . print_r(sprintf('%s <= %s <= %s', $mpLowerLimit, $mpNominal, $mpUpperLimit), true) . '</pre>';
//	die('STOP');

//	$isValid     = ((($mpNominal - $mpLowerTolerance) <= $mpValue) && ($mpValue <= ($mpNominal + $mpUpperTolerance)));
	/*$isSemiValid = (
		(false === $isValid) &&
		(
			(($mpNominal - ($mpLowerTolerance * $mpToleranceFactor)) <= $mpValue) &&
			($mpValue <= ($mpNominal + ($mpUpperTolerance * $mpToleranceFactor)))
		)
	);*/
	$isValid     = ($mpValue >= $mpLowerLimit) && ($mpValue <= $mpUpperLimit);

//	echo '<pre>$isValid: '     . print_r($isValid ? 'YES' : 'NO', true) . '</pre>';
////	echo '<pre>$isSemiValid: ' . print_r($isSemiValid ? 'YES' : 'NO', true) . '</pre>';
//	die('HALT');

//	echo '<pre>' . print_r(str_repeat('+', 80), true) . '</pre>';

	return ($isValid) ? 'valid' : 'invalid';
};
// Function to process the pressing log data.
$processCSV         = function(array $data) use(&$mockObject, &$calculateDistances, &$calculateForceGLMW): array
{
	$calculateFmax  = function(&$Fmax, &$FmaxGLMW5, &$FmaxGLMW20, &$similarity): int
	{
		$result = 0;

		try
		{
			$result = @((($FmaxGLMW20 / $FmaxGLMW5) * 100) < $similarity ? $FmaxGLMW20 : (($FmaxGLMW5 / $Fmax) * 100) < $similarity) ? $FmaxGLMW5 : $Fmax;
		}
		catch (Exception $e)
		{
			// Do nothing
		}

		return $result;
	};

	$distanceDeltas = $calculateDistances(array_column($data, 'distance'));
	$forceGLMW5     = $calculateForceGLMW(array_column($data, 'force'), 5, 2);
	$forceGLMW20    = $calculateForceGLMW(array_column($data, 'force'), 20, 4);

	$analysis = $mockObject->extract('analysis');

	$analysis->set('DistanceMax', (count($distanceDeltas)) ? round(max($distanceDeltas), 2) : 0);
	$analysis->set('Fmax',        (count(array_column($data, 'force'))) ? max(array_column($data, 'force')) : 0);
	$analysis->set('FmaxGLMW5',   (count($distanceDeltas)) ? round(max($forceGLMW5), 2) : 0);
	$analysis->set('FmaxGLMW20',  (count($distanceDeltas)) ? round(max($forceGLMW20), 4) : 0);
	$analysis->set('Similarity',  99.0);   // percentage

	$tracking = $mockObject->extract('tracking');

	$Fmax       = $analysis->get('Fmax');
	$FmaxGLMW5  = $analysis->get('FmaxGLMW5');
	$FmaxGLMW20 = $analysis->get('FmaxGLMW20');
	$Similarity = $analysis->get('Similarity');

	$Fmax = $calculateFmax( $Fmax, $FmaxGLMW5, $FmaxGLMW20, $Similarity );
	$Smax = $analysis->get('DistanceMax');

//	$tracking->set('F', ($Fmax > 0)  ? sprintf(trim('%d %s'),   $Fmax,  'N') : 0);
	$tracking->set('F', ($Fmax > 0) ? $Fmax : 0);
//	$tracking->set('Smax', ($S > 0 ) ? sprintf(trim('%.2f %s'), $Smax, 'mm') : 0);
	$tracking->set('S', ($Smax > 0) ? $Smax : 0);

	return [
		'analysis' => $analysis->toArray(),
		'tracking' => $tracking->toArray(),
	];
};
?>
<?php // Find all CSV files in the defined lookup directory.
if ($finder->files()->name('/^' . $csvFilePattern . '$/')->hasResults()) :
	echo '<pre>' . print_r(sprintf('has %d files to import.', $finder->count()), true) . '</pre>';
//	die('STOP');

	// Initialise database query object and data stack.
	$query  = $dbo->getQuery(true);
	$tuples = [];

	// Process found files.
	foreach ($finder as $csvFile) :
		echo '<pre>' . print_r(str_repeat('#', 100), true) . '</pre>';
//		continue;

		$csvReader = ReaderEntityFactory::createCSVReader();
		//$csvWriter = WriterEntityFactory::createCSVWriter();

		/** All of these methods have to be called before opening the reader. */
		$csvReader->setFieldDelimiter(';');
		$csvReader->setFieldEnclosure('"');
		$csvReader->setShouldPreserveEmptyRows(false);  // default behaviour, but here for learning

		/** Reset database query object */
		$query->clear();

		/** Read CSV file */
		try
		{
			echo '<pre>Processing machine log file: <span style="font-weight:bold">' . print_r($csvFile->getFilename(), true) . '</span></pre>';

			$csvReader->open($csvFile);

			//$xlsFile   = '';
			//$xlsReader = ReaderEntityFactory::createXLSXReader();
			//$xlsWriter = WriterEntityFactory::createXLSXWriter();

			$partID = $artID = $procID = $pressFit = 0;

			// Flag that indicates when the master data section has been processed.
			// At this point the actual measuring data is to be processed.
			$metaDataDone  = false;

			$measuringData = [];

			/** Read CSV file data into PHP data object */
			foreach ($csvReader->getSheetIterator() as $sheet)
			{
				// Get copy of $mockObject to start with an empty collection.
				$rowData = clone($mockObject);

				foreach ($sheet->getRowIterator() as $row)
				{
					$cells = $row->getCells();

					// Reset helper vars.
					$key   = $value = $halt = null;

					// Populate helper vars.
					$key   = trim('' . current($cells)->getValue());
					$value = trim('' . next($cells)->getValue());

					// Skip zero data line(s).
					if (empty($key) && empty($value)) :
						continue;
					endif;

					// Parse the master data.
					if (false == $metaDataDone)
					{
						// Separate measured information and unit, because they're separately stored into the database.
						if (stripos($key, 'Force/', 0) !== false)
						{
							$measurementTmp = explode('/', $key);
							$unitTmp        = explode('/', $value);

							$measurement    = array_shift($measurementTmp) . '/' . array_shift($unitTmp);
							$unit           = array_shift($measurementTmp) . '/' . array_shift($unitTmp);

							$rowData->set('measurement', $measurement);
							$rowData->set('unit', $unit);

							$metaDataDone = true;
						}
						else
						{
							// Fix specific values prior saving.
							switch (mb_strtolower($key))
							{
								case 'code' :
									$value = mb_strtoupper($value);
								break;

								case 'config' :
									$value    = ltrim($value, '-');
									$pressFit = explode('-', $value);

									$rowData->set('process',  mb_strtolower(array_shift($pressFit)));
									$rowData->set('pressFit', array_pop($pressFit));
								break;

								case 'operator' :
									// Handle "German Umlauts".
									$value = mb_strtolower($value);
									$value = preg_replace('/Ae/', 'Ä', $value);
									$value = preg_replace('/ae/', 'ä', $value);
									$value = preg_replace('/Oe/', 'Ö', $value);
									$value = preg_replace('/oe/', 'ö', $value);
									$value = preg_replace('/Ue/', 'Ü', $value);
									$value = preg_replace('/ue/', 'ü', $value);
									$value = utf8_ucwords($value);
								break;
							}

							$rowData->set(mb_strtolower($key), $value);
						}
					// In this block the pressing log data is parsed.
					}
					else
					{
						array_push($measuringData, ['force' => $key, 'distance' => $value]);
					}
				}

				$rowData->set('measuredData', $measuringData);
			}

			/** Read CSV file done. Close CSV file */
			$csvReader->close();

			/** DUPE check */
			$partID = $dbo->setQuery(sprintf('SELECT `partID`  FROM `parts`     WHERE `trackingcode` = %s', $dbo->q($rowData->get('code'))))->loadResult();
			$artID  = $dbo->setQuery(sprintf('SELECT `artID`   FROM `parts`     WHERE `partID`       = %d', $partID))->loadResult();
			$procID = $dbo->setQuery(sprintf('SELECT `procID`  FROM `processes` WHERE `abbreviation` = %s', $dbo->q($rowData->get('process'))))->loadResult();

			$isDuplicate = $dbo
			->setQuery(
				$query
				->from($dbo->qn($tableSCFData))
				->select($dbo->qn('partID'))
				->where($dbo->qn('partID')   . ' = ' . $dbo->q($partID))
				->where($dbo->qn('procID')   . ' = ' . $dbo->q($procID))
				->where($dbo->qn('config')   . ' = ' . $dbo->q($rowData->get('config')))
				->where($dbo->qn('pressFit') . ' = ' . $dbo->q($rowData->get('pressFit')))
			)
			->loadResult();

			if ($isDuplicate)
			{
				echo '<pre style="font-weight:bold; color:red">' .
					print_r('SKIPPED! This file was previously processed and tracked.', true) .	'</pre>';

				//TODO - Decide whether to put such files aside for later (re)handling
				continue;
			}

//			die('NO DUPE!');

			/** Calculate and add analysis and tracking data */
			$rowData->loadArray($processCSV($rowData->get('measuredData')));

			// Prepare row data for storing.
			preg_match('/([a-z0-9]{3}-?[a-z0-9]{3}-?[a-z0-9]{3})@([a-z0-9]{3}\.[a-z0-9]{3}\.[a-z0-9]{2}\.[a-z0-9]{5}\.[a-z0-9]{3})-([a-z]{3}\d{1,2})/i', $csvFile->getFilenameWithoutExtension(), $partInfo);
			echo '<pre>Part/Article/Process: <span style="font-weight:bold">' . print_r(sprintf('%s / %s / %s', $partInfo[1], $partInfo[2], $partInfo[3]), true) . '</span></pre>';
			echo '<pre>PartID/ArticleID/ProcessID: <span style="font-weight:bold">' . print_r(sprintf('%d / %d / %d', $partID, $artID, $procID), true) . '</span></pre>';
			echo '<pre>Tracking process: <span style="font-weight:bold">' . print_r(mb_strtoupper($rowData->get('process')), true) . '</span></pre>';
//			die('STOP');
			$procDrawing       = $dbo->setQuery(sprintf('SELECT `drawing` FROM `article_process` WHERE `artID`  = %d AND procID = %d', $artID, $procID))->loadResult();
			$procDrawing       = (JsonHelper::isValidJSON((string) $procDrawing)) ? json_decode($procDrawing) : null;
//			echo '<pre>procDrawing: ' . print_r($procDrawing, true) . '</pre>';
//			die('STOP');
			$procDrawingNumber = (is_object($procDrawing)) ? sprintf('%s.%s', $procDrawing->number, $procDrawing->index) : null;
			echo '<pre>Process drawing: <span style="font-weight:bold">' . print_r($procDrawingNumber, true) . '</span></pre>';
//			die('STOP');
			$analysisDataJSON  = json_encode($rowData->get('analysis'),     JSON_FORCE_OBJECT|JSON_PARTIAL_OUTPUT_ON_ERROR|JSON_THROW_ON_ERROR);
			$measuredDataJSON  = json_encode($rowData->get('measuredData'), JSON_FORCE_OBJECT|JSON_PARTIAL_OUTPUT_ON_ERROR|JSON_THROW_ON_ERROR);

			// Prepare measuring data to be stored into the part measuring data table.
			$tuple  = [
				'partID'       => $dbo->q($partID),
				'procID'       => $dbo->q($procID),
				'operator'     => $dbo->q($rowData->get('operator')),
				'machine'      => $dbo->q($rowData->get('machine')),
				'config'       => $dbo->q($rowData->get('config')),
				'pressFit'     => $dbo->q($rowData->get('pressFit')),
				'batch'        => $dbo->q($rowData->get('batch')),
				'measurement'  => $dbo->q($rowData->get('measurement')),
				'unit'         => $dbo->q($rowData->get('unit')),
				'analysis'     => $dbo->q($analysisDataJSON),
				'measuredData' => $dbo->q($measuredDataJSON),
				// 'timestamp'    => "NULL",	// Added by MySQL
			];
			// Push to stack.
			$tuples = [implode(',', $tuple)];

			// Prepare process tracking data to be stored into the part techparams table.
			/*$processTrackingData = [
				'form' => [
					'procParams' => [
						$procID => [
							Techparams::STATIC_TECHPARAM_ORGANISATION => 'FRÖTEK-Kunststofftechnik GmbH (OHA)',    //FIXME - make this dynamic! But, from which user to take?
							Techparams::STATIC_TECHPARAM_OPERATOR     => rtrim(ltrim($tuple['operator'], "'"), "'"),
							Techparams::STATIC_TECHPARAM_DATE         => date_create()->format('Y-m-d'),
							Techparams::STATIC_TECHPARAM_TIME         => date_create()->format('H:i:s'),
							Techparams::STATIC_TECHPARAM_DRAWING      => $procDrawingNumber,
							Techparams::STATIC_TECHPARAM_ERROR        => 0,    // 0 means the part is good ... no error(s)
							Techparams::STATIC_TECHPARAM_ANNOTATION   => 'Automatically tracked by connected machine',
						]
					]
				]
			];*/

			echo '<pre>rowData: '               . print_r($rowData, true) . '</pre>';
//			echo '<pre>Process machine data: '  . print_r($tuples, true) . '</pre>';
//			echo '<pre>Process tracking data: ' . print_r($processTrackingData, true) . '</pre>';
//			die('Ready2Store');
//			continue;

			/** Store data into the database */

			/* 1. Store log data no matter what */

			echo '<pre><span style="font-weight:bold; color:blue">STEP 1:</span> ' . print_r('Store Log data.', true) . '</pre>';
//			die('STOP');

			// Init flag variable.
			$stored = null;

			if (count($tuples))
			{
				// Build query.
				$query
				->insert($dbo->qn($tableSCFData))
				->columns($dbo->qn($columnsSCFData))
				->values($tuples);

//				echo '<pre><span style="font-weight:bold; color:maroon">Query 1:</span> ' . print_r($query->dump(), true) . '</pre>';

				// $stored = $dbo
				// ->setQuery($query)
				// ->execute();
				$stored = true;	// temp disable real execution
			}

			echo '<pre>Log data stored? <span style="font-weight:bold; color:' . ($stored ? 'green' : 'red') . '">' . print_r($stored ? 'YES' : sprintf('Failed to store press in data for part %d.', $partID), true) . '</span></pre>';
//			die('STOP');

			/* 2. Store measuring data and track process */

			if (false === $stored)
			{
				//TODO - Log error.
			}

			/* 2.1 Track process measuring points */

			// Reset $tuples for next usage.
			$tuples  = [];

			// Get marker for this part and process.
			$markers = (array) $mpIdentifiersMap->get(preg_replace('/^([A-Za-z]+)\d{1,}$/', '$1', $rowData->get('process')));

			echo '<pre>Get markers for process: ' . print_r(preg_replace('/^([A-Za-z]+)\d{1,}$/', '$1', $rowData->get('process')), true) . '</pre>';
//			echo '<pre>Markers: ' . print_r($markers, true) . '</pre>';
//			die('STOP');

			// Get measuring point for this part and process.
			if (empty($markers))
			{
				echo '<pre style="color:red">' . print_r('This process has no measuring point identification markers. Tracking impossible!', true) . '</pre>';
//				die('STOP');
			}
			else
			{
				echo '<pre><span style="font-weight:bold; color:blue">STEP 2:</span> ' . print_r('Get measuring definitions.', true) . '</pre>';
//				die('STOP');

				$query
				->clear()
				->from($dbo->qn($tableMPDefs, 'apmpd'))
				->select($dbo->qn('apmpd.*'))
				->where($dbo->qn('apmpd.artID')  . ' = (SELECT `artID` FROM `parts` WHERE `partID` = ' . (int) $partID . ')')
				->where($dbo->qn('apmpd.procID') . ' = ' . (int) $procID)
				->where($dbo->qn('apmpd.mpDescription') . ' = ' . $dbo->q($rowData->get('config')))
				->order($dbo->qn('apmpd.mp'));   // Note: Ordering is important to ensure referencing via index will work correctly

//				echo '<pre><span style="font-weight:bold; color:maroon">Query 2:</span> ' . print_r($dbo->getQuery()->dump(), true) . '</pre>';
//				die('STOP');

				$mpDefinitions = $dbo
				->setQuery($query)
				->loadAssocList();

//				echo '<pre>Measuring definitions: ' . print_r(($mpDefinitions), true) . '</pre>';
//				die('STOP');

				$mPoints = (array) array_column($mpDefinitions, 'mp');

				echo '<pre>Measuring points for this process: <span style="font-weight:bold">' . print_r(json_encode($mPoints), true) . '</span></pre>';
//				die('STOP');

				if (!count($mPoints))
				{
					echo '<pre style="font-weight:bold; color:red">' .
					print_r(sprintf('This article has no measuring point(s) defined for process <span style="color:black">%s</span>. Processing aborted!', mb_strtoupper($rowData->get('process'))), true) .	'</pre>';

					//TODO - Decide whether to puth such files aside for later (re)handling
					continue;
				}

				$tracking = $rowData->get('tracking');
				$validity = [];
				$time     = date_create('NOW');

				echo '<pre>Identifier(s): <span style="font-weight:bold">' . print_r(json_encode($markers), true) . '</span></pre>';
//				die('STOP');

//				echo '<pre>Measuring data for this process: <span style="font-weight:bold">' . print_r(json_encode($tracking), true) . '</span></pre>';
//				die('STOP');

				echo '<pre><span style="font-weight:bold; color:blue">STEP 3:</span> ' . print_r('Validate machine data.', true) . '</pre>';
//				die('STOP');


				for ($i = 0, $j = count($markers); $i < $j; $i += 1)
				{
					date_add($time, date_interval_create_from_date_string('1 second'));
					
					echo '<pre>' . print_r(sprintf('Validation measuring point %s ...', $mPoints[$i]), true) . '</pre>';

					$validity[$i] = $calculateValidity($tracking->{$markers[$i]}, $mpDefinitions[$i]);

					echo '<pre>  Value is: <span style="font-weight:bold; color:' . ($validity[$i] == 'valid' ? 'green' : 'red') . '">' . print_r($validity[$i], true) . '</span></pre>';
					// echo '<pre>  Value ' . $markers[$i] . ' is: <span style="font-weight:bold; color:' . ($validity[$i] == 'valid' ? 'green' : 'red') . '">' . print_r($validity[$i], true) . '</span></pre>';
//				    die('STOP');

					$tuple = [
						'partID'            => $partID,
						'procID'            => $procID,
						'mp'                => $mpDefinitions[$i]['mp'],
						'mpInput'           => $tracking->{$markers[$i]},
						'mpNominal'         => $mpDefinitions[$i]['mpNominal'],
						'mpLowerTol'        => $mpDefinitions[$i]['mpLowerTol'],
						'mpUpperTol'        => $mpDefinitions[$i]['mpUpperTol'],
						'mpToleranceFactor' => $mpTolerance,
						'mpValidity'        => $validity[$i],
						'timestamp'         => $time->format('Y-m-d H:i:s')	// We set this timestamp explicitly, because without it the correct mp-ordering is unintuitive
					];

					// Push to stack.
					// $tuples[$i] = $tuple;
//					$tuples[$i] = implode(',', $tuple);
					$tuples[$tuple['mp']] = $tuple;
				}

				echo '<pre>' . print_r('Validatation completed.', true) . '</pre>';
//				die('STOP');

				echo '<pre><span style="font-weight:bold; color:blue">STEP 4:</span> ' . print_r('Store measuring data for this process.', true) . '</pre>';
//				echo '<pre>Measuring data: ' . print_r($tuples, true) . '</pre>';
//				die('STOP');

				// Inject 2 additional techparams according to current process.
				//TODO - Fetch additional techparams depending on process (mtn, scf, etc.)
//				$processTrackingData['form']['procParams'][$procID][10] = $rowData->get('machine');
//				$processTrackingData['form']['procParams'][$procID][39] = $rowData->get('batch');		//FIXME - Wenn es mehr als 1 Einpressteil gibt, muss dieser Parameter
																										//        erweitert werden und nicht überschrieben
//				$processTrackingData['form']['procMeasurementData'][$procID] = $tuples;

//				echo '<pre>Tracking data: ' . print_r($processTrackingData, true) . '</pre>';
//				die('STOP');
			}

			// Check if there is already a previous tracking entry for this part and process.
			$query
			->clear()
			->from($dbo->qn($tableTrk, 'ptp'))
			->select($dbo->qn('ptp.partID'))
			->where($dbo->qn('ptp.partID')  . ' = ' . (int) $partID)
			->where($dbo->qn('ptp.procID')  . ' = ' . (int) $procID)
			->where($dbo->qn('ptp.paramID') . ' = ' . Techparams::STATIC_TECHPARAM_DATE);

			echo '<pre><span style="font-weight:bold; color:maroon">Query 3:</span> ' . print_r($dbo->getQuery()->dump(), true) . '</pre>';
//			die('STOP');

			$tracked = $dbo
			->setQuery($query)
			->loadResult();

			echo '<pre><span style="font-weight:bold; color:blue">STEP 5:</span> ' . print_r('Track this process.', true) . '</pre>';
//			echo '<pre><span style="font-weight:bold; color:maroon">Query 4:</span>: ' . print_r($dbo->getQuery()->dump(), true) . '</pre>';
			echo '<pre>Was this process already tracked? <span style="font-weight:bold; color:' . ($tracked ? 'red' : 'green') . '">' . print_r($tracked ? 'YES' : 'NO', true) . '</span></pre>';
//			die('STOP');

			/* 2.2 Track process master data */

			// If there is no previous tracking entry, we're good to go.
			// Otherwise we should leave existing tracking data unchanged, shouldn't we?
			//FIXME - Decide on what to do if there is already an incomplete tracking entry (master data but no measuring data)?
			if (!$tracked)
			{
				$processTrackingData = [
					'form' => [
						'procParams' => [
							$procID => [
								Techparams::STATIC_TECHPARAM_ORGANISATION => 'FRÖTEK-Kunststofftechnik GmbH (OHA)',    //FIXME - make this dynamic! But, from which user to take?
								Techparams::STATIC_TECHPARAM_OPERATOR     => $rowData->get('operator'),
								Techparams::STATIC_TECHPARAM_DATE         => date_create()->format('Y-m-d'),
								Techparams::STATIC_TECHPARAM_TIME         => date_create()->format('H:i:s'),
								Techparams::STATIC_TECHPARAM_DRAWING      => $procDrawingNumber,
								Techparams::STATIC_TECHPARAM_ERROR        => 0,    // 0 means the part is good ... no error(s)
								Techparams::STATIC_TECHPARAM_ANNOTATION   => 'Automatically tracked by connected machine',
								10 => $rowData->get('machine'),
								39 => $rowData->get('batch')
							]
						],
						'procMeasurementData' => [
							$procID => $tuples
						]
					]
				];

//				echo '<pre>rowData: ' . print_r($rowData, true) . '</pre>';
//				echo '<pre>Track process master data: ' . print_r($processTrackingData, true) . '</pre>';
//				die('STOP');
			}
			else
			{
				echo '<pre>Previous tracking: ' . print_r($tracked, true) . '</pre>';
//				die('STOP');
				echo '<pre>' . print_r('Override previous tracking with current tracking data.', true) . '</pre>';
				echo '<pre style="color:red">' . print_r('SHALL I REALLY DO???', true) . '</pre>';
//				die('STOP');

				$part             = Model::getInstance('part')->getItem((int) $partID);
				$partTrackedData  = $part->get('trackingData');
				$partTrackedData  = (array) ArrayHelper::getValue($partTrackedData,  $procID, []);
				$partMeasuredData = $part->get('measuredData');
				$partMeasuredData = (array) ArrayHelper::getValue($partMeasuredData, $procID, []);
				$lastTrackedTime  = ArrayHelper::getValue(end($partMeasuredData), 'timestamp');
				$lastTrackedTime  = date_create($lastTrackedTime);

//				echo '<pre>part: ' . print_r($part, true) . '</pre>';
				// echo '<pre>partTrackedData: '  . print_r($partTrackedData,  true) . '</pre>';
				echo '<pre>partMeasuredData: ' . print_r($partMeasuredData, true) . '</pre>';
				echo '<pre>lastTrackedTime: '  . print_r($lastTrackedTime, true) . '</pre>';
				// die('STOP');

//				echo '<pre>tuples prior injection for update: ' . print_r($tuples, true) . '</pre>';
//				die('STOP');

				// Append this dataset's batch number to previously tracked batch number.
				/*$query
				->clear()
				->from($dbo->qn($tableTrk, 'ptp'))
				->select($dbo->qn('ptp.paramValue'))
				->where($dbo->qn('ptp.partID')  . ' = ' . (int) $partID)
				->where($dbo->qn('ptp.procID')  . ' = ' . (int) $procID)
				->where($dbo->qn('ptp.paramID') . ' = ' . 39);	//FIXME - Hardcoding this paramID is potentially inconsistent as it might change in the future. Better fetch this paramID from the database.

				echo '<pre><span style="font-weight:bold; color:maroon">Query 3:</span> ' . print_r($dbo->getQuery()->dump(), true) . '</pre>';
//				die('STOP');

				$batchNum = $dbo
				->setQuery($query)
				->loadResult();*/

				// Append measuring data tuples from currently processed file to previously tracked measuring data.
				/* $tuples = array_filter($tuples, function(&$tuple, $mp) use(&$partMeasuredData, &$lastTrackedTime)
				{
					// Skip duplicates.
					if (array_key_exists($mp, $partMeasuredData))
					{
						echo '<pre><em>' . print_r(sprintf('%s was previously tracked. Skipped!', $mp), true) . '</em></pre>';

						return false;
					}
					
					date_add($lastTrackedTime, date_interval_create_from_date_string('1 second'));
					
					$tuple['timestamp'] = $lastTrackedTime->format('Y-m-d H:i:s');

					return true;
				}, ARRAY_FILTER_USE_BOTH); */
				
				foreach ($tuples as $mp => $tuple)
				{
					if (array_key_exists($mp, $partMeasuredData))
					{
						unset($partMeasuredData[$mp]);
						
						echo '<pre><em>' . print_r(sprintf('%s was previously tracked. Skipped!', $mp), true) . '</em></pre>';

						continue;
					}
					
					date_add($lastTrackedTime, date_interval_create_from_date_string('1 second'));
					
					$tuples[$mp]['timestamp'] = $lastTrackedTime->format('Y-m-d H:i:s');
				}

				// Replace new measuring data with updated version.
				if (count($tuples))
				{
					echo '<pre>tuples to inject for update: ' . print_r($tuples, true) . '</pre>';
//					die('STOP');

					$processTrackingData = [
						'form' => [
							'procParams' => [
								$procID => [
									Techparams::STATIC_TECHPARAM_ORGANISATION => 'FRÖTEK-Kunststofftechnik GmbH (OHA)',    //FIXME - make this dynamic! But, from which user to take?
									Techparams::STATIC_TECHPARAM_OPERATOR     => $rowData->get('operator'),
									Techparams::STATIC_TECHPARAM_DATE         => date_create()->format('Y-m-d'),
									Techparams::STATIC_TECHPARAM_TIME         => date_create()->format('H:i:s'),
									Techparams::STATIC_TECHPARAM_DRAWING      => $procDrawingNumber,
									Techparams::STATIC_TECHPARAM_ERROR        => 0,    // 0 means the part is good ... no error(s)
									Techparams::STATIC_TECHPARAM_ANNOTATION   => 'Automatically tracked by connected machine',
									10 => $rowData->get('machine'),
									39 => trim(
										// Append batch number.
										ArrayHelper::getValue($partTrackedData, '39', '', 'STRING') . // Previously tracked batch number(s)
										', ' .
										$rowData->get('batch')		  								  // New batch number(s) from currently processed file
									)
								]
							],
							'procMeasurementData' => [
								// Append measuring data to preserve previously tracked data while current tracking data.
								$procID => array_merge($partMeasuredData, $tuples)
							]
						]
					];
				}
				else
				{
					echo '<pre style="color:red">' . print_r('After filtering there\'s nothing left for tracking.', true) . '</pre>';
				}
			}

			// If there is something to track, hand it over to part model function and let it do this job, since it is already implemented there.
			if (!empty($processTrackingData))
			{
//				echo '<pre>processTrackingData to store: ' . print_r($processTrackingData, true) . '</pre>';
//				die('STOP');

				$tracked = $partModel->storeTrackingData($partID, $procID, $processTrackingData);
//				$tracked = true;
			}
		}
		catch (IOException $e)
		{
			//TODO - Log error.
			echo '<pre style="color:red">' . print_r(sprintf('Failed to read CSV file %s.', $csvFile), true) . '</pre>';
//			die('STOP');
			continue;
		}
		catch (ReaderNotOpenedException $e)
		{
			//TODO - Log error.
			echo '<pre style="color:red">' . print_r('CSV-Reader not opened.', true) . '</pre>';
//			die('STOP');
			continue;
		}
		catch (Joomla\Database\Exception\ExecutionFailureException $e)
		{
			switch ($e->getCode())
			{
				case '1066' :
					// Do just nothing
				break;

				default :
					//TODO - Log error.
					echo '<pre style="color:red">' . print_r('Database query failed.', true) . '</pre>';
//			        die('STOP');
			}
		}
		catch (JsonException $e)
		{
			//TODO - Log error.
			echo '<pre style="color:red">' . print_r('Failed to prepare JSON data for storing.', true) . '</pre>';
//			die('STOP');
			continue;
		}
		catch (Exception $e)
		{
			//TODO - Log error.
			echo '<pre style="color:red">' . print_r('An unspecified error occurred.', true) . '</pre>';
			echo '<pre>ERROR: ' . print_r($e->getMessage(), true) . '</pre>';
			die('STOP');
			continue;
		}
	endforeach;
endif;

echo '<pre>' . print_r(str_repeat('#', 100), true) . '</pre>';
echo '<pre>' . print_r('CSV import completed.', true) . '</pre>';
die;
